<?php

/**
 * @file
 * Defines a field type for referencing other entites.
 */

/**
 * Implements hook_entity_info_alter().
 *
 * TO DO: Patch core entities to have each provide its own values.
 */
function reference_entity_info_alter(&$entity_info) {
  $entity_info['comment']['entity keys']['label'] = 'subject';
  $entity_info['comment']['entity keys']['status'] = 'status';
  $entity_info['file']['entity keys']['label'] = 'filename';
  $entity_info['file']['entity keys']['status'] = 'status';
  $entity_info['node']['entity keys']['label'] = 'title';
  $entity_info['node']['entity keys']['status'] = 'status';
  $entity_info['taxonomy_term']['entity keys']['label'] = 'name';
  $entity_info['user']['entity keys']['label'] = 'name';
  $entity_info['user']['entity keys']['status'] = 'status';
}

/**
 * Implements hook_field_info() to define the reference field.
 */
function reference_field_info() {
  return array(
    'reference' => array(
      'label' => t('Reference'),
      'description' => t('Defines a field type for referencing other entities.'),
      'settings' => array(
        'entity_type' => '',
      ),
      'instance_settings' => array(
        'bundles' => '',
        'status' => '',
      ),
      'default_widget' => 'reference_autocomplete',
      'default_formatter' => 'reference_link',
    ),
  );
}

/**
 * Implements hook_field_settings_form() for setting the field options.
 */
function reference_field_settings_form($field, $instance, $has_data) {
  // Find all available entity types to allow one to be selected.
  $entity_type_options = array();
  foreach (entity_get_info() as $entity_type => $entity_type_info) {
    // Ensure that the entity type has registered its label entity key.
    if (isset($entity_type_info['entity keys']['label'])) {
      $entity_type_options[$entity_type] = $entity_type_info['label'];
    } else {
      backdrop_set_message(t("The @entity entity type has not declared its label attribute and cannot be referenced.", array('@entity' => $entity_type_info['label'])), 'warning');
    }
  }
  // Build the field settings form.
  $form = array();
  $form['entity_type'] = array(
    '#type' => 'select',
    '#title' => t('Select the entity type to be referenced.'),
    '#options' => $entity_type_options,
    '#default_value' => $field['settings']['entity_type'],
    '#required' => TRUE,
    '#disabled' => $has_data,
  );
  return $form;
}

/**
 * Implements hook_field_instance_settings_form() for setting instance options.
 */
function reference_field_instance_settings_form($field, $instance) {
  // Determine the options for the entity bundles selection.
  $bundles_options = array();
  $entity_type_info = entity_get_info($field['settings']['entity_type']);
  foreach ($entity_type_info['bundles'] as $bundle => $bundle_info) {
    $bundles_options[$bundle] = $bundle_info['label'];
  }
  // Build the field instance setting form.
  $form = array();
  $form['status'] = array(
    '#type' => 'checkbox',
    '#title' => t('Limit to published content'),
    '#default_value' =>  $instance['settings']['status'],
    // Ensure that the entity type has registered its status entity info key.
    '#disabled' => !isset($entity_type_info['entity keys']['status']),
    '#description' => !isset($entity_type_info['entity keys']['status']) ? t("Notice: This entity type has not declared its status attribute.") : '',
  );
  $form['bundles'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Allowed bundles'),
    '#description' => t('Leave unchecked to allow all bundles to be referenced.'),
    '#options' => $bundles_options,
    '#multiple' => TRUE,
    '#default_value' =>  $instance['settings']['bundles'],
  );
  return $form;
}

/**
 * Implements hook_field_is_empty() so forms know if a field is empty.
 */
function reference_field_is_empty($item, $field) {
  return empty($item['target_id']);
}

/**
 * Implements hook_field_validate() so forms know if a field value is valid.
 */
function reference_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {
  foreach ($items as $delta => $item) {
    // Only validate fields that aren't empty.
    if (!reference_field_is_empty($item, $field)) {
      // Make sure the referenced entity exists.
      if (!entity_load($field['settings']['entity_type'], $item['target_id'])) {
        $errors[$field['field_name']][$langcode][$delta][] = array(
          'error' => 'reference_exists',
          'message' => t('%name: the referenced entity (%target_type %target_id) does not exist.', array(
            '%name' => $instance['label'],
            '%target_type' => $field['settings']['entity_type'],
            '%target_id' => $item['target_id'],
          )),
        );
      }
    }
  }
}

/**
 * Implements hook_field_formatter_info() to register the field formatter.
 */
function reference_field_formatter_info() {
  return array(
    'reference_link' => array(
      'label' => t('Reference link'),
      'field types' => array('reference'),
    ),
  );
}

/**
 * Implements hook_field_formatter_view() to render the field for display.
 */
function reference_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  if ($display['type'] == 'reference_link') {
    return reference_link_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display);
  }
}

/**
 * Called from reference_field_formatter_view() to create the formatter view.
 */
function reference_link_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
  foreach ($items as $delta => $target) {
    $target_type = $field['settings']['entity_type'];
    $target_type_info = entity_get_info($target_type);
    $target_label_property = $target_type_info['entity keys']['label'];
    $target_entity = entity_load($target_type, $target['target_id']);
    $element[] = array(
      '#markup' => l($target_entity->$target_label_property, $target_entity->path['source']),
    );
  }
  return $element;
}
