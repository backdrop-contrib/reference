<?php

/**
 * @file
 * Defines a field type for referencing other entites.
 */

/**
 * Implements hook_entity_info_alter().
 *
 * TO DO: Patch core entities to have each provide its own values.
 */
function reference_entity_info_alter(&$entity_info) {
  $entity_info['node']['entity keys']['label'] = 'title';
  $entity_info['node']['entity keys']['status'] = 'status';
}

/**
 * Implements hook_menu().
 */
function reference_menu() {
  $items['reference_autocomplete'] = array(
    'page callback' => 'reference_autocomplete',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implements hook_field_info().
 */
function reference_field_info() {
  return array(
    'reference' => array(
      'label' => t('Reference'),
      'description' => t('Defines a field type for referencing other entites.'),
      'instance_settings' => array(
        'entity_type' => '',
        'bundle' => '',
        'status' => '',
      ),
      'default_widget' => 'reference_autocomplete',
      'default_formatter' => 'simple_link',
    ),
  );
}

/**
 * Implements hook_field_settings_form().
 */
function reference_field_settings_form($field, $instance, $has_data) {
  $settings = $field['settings'];
  $form = array();
  $form['entity_type'] = array(
    '#type' => 'select',
    '#title' => t('Select entity type to reference'),
    '#options' => _reference_entity_options(),
    '#default_value' => isset($settings['entity_type']) ? $settings['entity_type'] : 'node',
  );
  return $form;
}

/**
 * Implements hook_field_instance_settings_form().
 */
function reference_field_instance_settings_form($field, $instance) {
  $settings = $instance['settings'];
  $form['status'] = array(
    '#type' => 'checkbox',
    '#title' => t('Limit to published content'),
    '#default_value' => $settings['status'],
  );
  $form['bundles'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Limit to bundles'),
    '#options' => _reference_entity_bundle_options($field['settings']['entity_type']),
    '#multiple' => TRUE,
    '#description' => t('Leave unchecked to allow all entity type bundles to be referenced.'),
    '#default_value' => isset($settings['bundles']) ? $settings['bundles'] : array(),
  );
  return $form;
}

/**
 * Implements hook_field_is_empty().
 */
function reference_field_is_empty($item, $field) {
  return empty($item['target_id']);
}

/**
 * Implements hook_field_validate().
 */
function reference_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {
  foreach ($items as $delta => $item) {
    // Only validate fields that aren't empty.
    if (!reference_field_is_empty($item, $field)) {
      // Make sure the referenced entity exists.
      if (!entity_load($item['target_type'], $item['target_id'])) {
        $errors[$field['field_name']][$langcode][$delta][] = array(
          'error' => 'reference_exists',
          'message' => t('%name: the referenced entity (%target_type %target_id) does not exist.', array(
            '%name' => $instance['label'],
            '%target_type' => $item['target_type'],
            '%target_id' => $item['target_id'],
          )),
        );
      }
    }
  }
}

/**
 * Implements hook_field_widget_info().
 */
function reference_field_widget_info() {
  return array(
    'reference_autocomplete' => array(
      'label' => t('Autocomplete'),
      'field types' => array('reference'),
    ),
  );
}

/**
 * Implements hook_field_widget_form().
 */
function reference_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  $element['target_type'] = array(
    '#type' => 'select',
    '#description' => 'Entity type',
    '#options' => array($field['settings']['entity_type'] => entity_get_info($field['settings']['entity_type'])['label']),
    '#default_value' => isset($items[$delta]['target_type']) ? $items[$delta]['target_type'] : '',
  );
  $element['target_id'] = array(
    '#type' => 'textfield',
    '#description' => 'Entity id',
    '#default_value' => isset($items[$delta]['target_id']) ? $items[$delta]['target_id'] : '',
    '#autocomplete_path' => 'reference_autocomplete/' . $field['settings']['entity_type'],
    '#element_validate' => array('reference_autocomplete_validate'),
    '#value_callback' => 'reference_autocomplete_value',
    '#default_target_type' => isset($items[$delta]['target_type']) ? $items[$delta]['target_type'] : null,
  );
  return $element;
}

/**
 * Callback for providing autocomplete values to the reference fields.
 */
function reference_autocomplete($target_type = NULL, $typed = '') {
  $matches = array();
  if ($target_type && $entity_info = entity_get_info($target_type)) {
    $base_table = $entity_info['base table'];
    $id_field = $entity_info['entity keys']['id'];
    $label_field = $entity_info['entity keys']['label'];

    $result = db_select($base_table, 'bt')
      ->fields('bt', array($id_field, $label_field))
      ->condition($label_field, '%' . db_like($typed) . '%', 'LIKE')
      ->orderBy($label_field)
      ->range(0, 10)
      ->execute();

    foreach ($result as $entity) {
      $item = _reference_autocomplete_item_format($entity_info['label'], $entity->{$id_field}, $entity->{$label_field});
      $matches[$item] = $item;
    }
  }
  backdrop_json_output($matches);

  // TO DO: Why is the echo in backdrop_json_output not disabling the theme?
  module_invoke_all('exit');
  exit();
}

/**
 * Callback for to validate the values inserted into the field after autocompleting.
 */
function reference_autocomplete_validate($element, &$form_state, $form) {
  if (!empty($element['#value'])) {
    if ($id = _reference_autocomplete_item_extract_id($element['#value'])) {
      form_set_value($element, $id, $form_state);
    }
    else {
      form_set_value($element, "", $form_state);
      form_error($element, t('The reference field value must contain a numeric id.'));
    }
  }
}

/**
 * Callback for turning a numeric value of a field into the autocomplete format.
 */
function reference_autocomplete_value($element, $input = FALSE, $form_state = array()) {
  if(isset($element['#default_target_type']) && isset($element['#default_value'])) {
    $target_type_info = entity_get_info($element['#default_target_type']);
    $target_label_property = $target_type_info['entity keys']['label'];
    $target_entity = entity_load($element['#default_target_type'], $element['#default_value']);
    return _reference_autocomplete_item_format($element['#default_target_type'], $element['#default_value'], $target_entity->{$target_label_property});
  }
}

/**
 * Helper function to turn the label and value into an autocomplete item
 */
function _reference_autocomplete_item_format($type, $id, $label) {
  return $label . " (" . $id . ")";
}

/**
 * Helper function to extract the entity id from an autocompleted item
 */
function _reference_autocomplete_item_extract_id($value) {
  if (is_numeric($value)) {
    return $value;
  }
  preg_match('/.*\(([0-9]*)\)$/', $value, $matches);
  if (isset($matches[1])) {
    return $matches[1];
  }
  return false;
}

/**
 * Implements hook_field_formatter_info().
 */
function reference_field_formatter_info() {
  return array(
    'simple_link' => array(
      'label' => t('Simple link'),
      'field types' => array('reference'),
    ),
  );
}

/**
 * Implements hook_field_formatter_view().
 */
function reference_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
  switch ($display['type']) {
    case 'simple_link':
      foreach ($items as $delta => $target) {
        $target_type_info = entity_get_info($target['target_type']);
        $target_label_property = $target_type_info['entity keys']['label'];
        $target_entity = entity_load($target['target_type'], $target['target_id']);
        $element[] = array(
          '#markup' => l($target_entity->$target_label_property, $target_entity->path['source']),
        );
      }
      break;
  }
  return $element;
}

/**
 * Helper: Get the entity types and return an option array.
 */
function _reference_entity_options() {
  $options = array();
  $entity_types = entity_get_info();
  foreach ($entity_types as $key => $type) {
    $options[$key] = $type['label'];
  }
  return $options;
}

/**
 * Helper: Get the bundle info for an entity type and an option array.
 */
function _reference_entity_bundle_options($entity_type) {
  $options = array();
  $bundles = field_info_bundles($entity_type);
  foreach ($bundles as $key => $info) {
    $options[$key] = $info['label'];
  }
  return $options;
}
