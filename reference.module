<?php

/**
 * @file
 * Defines a field type for referencing other entites.
 */

/**
 * Implements hook_entity_info_alter().
 *
 * TO DO: Patch core entities to have each provide its own values.
 */
function reference_entity_info_alter(&$entity_info) {
  $entity_info['comment']['entity keys']['label'] = 'subject';
  $entity_info['comment']['entity keys']['status'] = 'status';
  $entity_info['file']['entity keys']['label'] = 'filename';
  $entity_info['file']['entity keys']['status'] = 'status';
  $entity_info['node']['entity keys']['label'] = 'title';
  $entity_info['node']['entity keys']['status'] = 'status';
  $entity_info['taxonomy_term']['entity keys']['label'] = 'name';
  $entity_info['user']['entity keys']['label'] = 'name';
  $entity_info['user']['entity keys']['status'] = 'status';
}

/**
 * Implements hook_menu() to provide autocomplete callback.
 */
function reference_menu() {
  $items['reference_autocomplete'] = array(
    'page callback' => 'reference_autocomplete',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
    'file' => 'includes/reference_autocomplete.field_widget.inc'
  );
  return $items;
}

/**
 * Implements hook_field_info() to define the reference field.
 */
function reference_field_info() {
  return array(
    'reference' => array(
      'label' => t('Reference'),
      'description' => t('Defines a field type for referencing other entities.'),
      'settings' => array(
        'entity_type' => '',
      ),
      'instance_settings' => array(
        'bundles' => '',
        'status' => '',
      ),
      'default_widget' => 'reference_autocomplete',
      'default_formatter' => 'reference_link',
    ),
  );
}

/**
 * Implements hook_field_settings_form() for setting the field options.
 */
function reference_field_settings_form($field, $instance, $has_data) {
  $entity_type_options = array();
  foreach (entity_get_info() as $entity_type => $entity_type_info) {
    $entity_type_options[$entity_type] = $entity_type_info['label'];
  }
  $form = array();
  $form['entity_type'] = array(
    '#type' => 'select',
    '#title' => t('Select the entity type to be referenced.'),
    '#options' => $entity_type_options,
    '#default_value' => $field['settings']['entity_type'],
    '#required' => TRUE,
    '#disabled' => $has_data,
  );
  return $form;
}

/**
 * Implements hook_field_instance_settings_form() for setting instance options.
 */
function reference_field_instance_settings_form($field, $instance) {
  // Determine the options for the entity bundles selection.
  $bundles_options = array();
  $entity_type_info = entity_get_info($field['settings']['entity_type']);
  foreach ($entity_type_info['bundles'] as $bundle => $bundle_info) {
    $bundles_options[$bundle] = $bundle_info['label'];
  }
  // Build the field instance setting form.
  $form = array();
  $form['status'] = array(
    '#type' => 'checkbox',
    '#title' => t('Limit to published content'),
    '#default_value' =>  $instance['settings']['status'],
  );
  $form['bundles'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Allowed bundles'),
    '#description' => t('Leave unchecked to allow all bundles to be referenced.'),
    '#options' => $bundles_options,
    '#multiple' => TRUE,
    '#default_value' =>  $instance['settings']['bundles'],
  );
  return $form;
}

/**
 * Implements hook_field_is_empty() so forms know if a field is empty.
 */
function reference_field_is_empty($item, $field) {
  return empty($item['target_id']);
}

/**
 * Implements hook_field_validate() so forms know if a field value is valid.
 */
function reference_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {
  foreach ($items as $delta => $item) {
    // Only validate fields that aren't empty.
    if (!reference_field_is_empty($item, $field)) {
      // Make sure the referenced entity exists.
      if (!entity_load($item['target_type'], $item['target_id'])) {
        $errors[$field['field_name']][$langcode][$delta][] = array(
          'error' => 'reference_exists',
          'message' => t('%name: the referenced entity (%target_type %target_id) does not exist.', array(
            '%name' => $instance['label'],
            '%target_type' => $item['target_type'],
            '%target_id' => $item['target_id'],
          )),
        );
      }
    }
  }
}

/**
 * Implements hook_field_widget_info() to define an autocomplete form widget.
 */
function reference_field_widget_info() {
  return array(
    'reference_autocomplete' => array(
      'label' => t('Autocomplete'),
      'field types' => array('reference'),
    ),
  );
}

/**
 * Implements hook_field_widget_form() to provide an autocomplete form widget .
 */
function reference_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  require_once 'includes/reference_autocomplete.field_widget.inc';
  return reference_autocomplete_widget_form($form, $form_state, $field, $instance, $langcode, $items, $delta, $element);
}

/**
 * Implements hook_field_formatter_info() to register the field formatter.
 */
function reference_field_formatter_info() {
  return array(
    'reference_link' => array(
      'label' => t('Reference link'),
      'field types' => array('reference'),
    ),
  );
}

/**
 * Implements hook_field_formatter_view() to render the field for display.
 */
function reference_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  if ($display['type'] == 'reference_link') {
    require_once 'includes/reference_link.field_formatter.inc';
    return reference_link_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display);
  }
}
